name: Reusable run example
on: [ workflow_call ]
inputs:
  folder-path:
    description: 'folder path where we want to run the tests'
    required: 'false'
    default: '.'
runs:
  using: "composite"
  steps:
    - name: register project architecture for later
      run: ls -lRS > /tmp/tree_hierarchy
      shell: bash
      working-directory: ${{ inputs.folder-path }}

    - name: make all
      run: make all
      shell: bash
      working-directory: ${{ inputs.folder-path }}

    - name: register release output for later
      run: ./$(grep NAME < config.mk | grep -v NAME_DEBUG | cut -d'=' -f2 | xargs) > /tmp/release_output
      shell: bash
      working-directory: ${{ inputs.folder-path }}

    - name: make clean
      run: make clean
      shell: bash
      working-directory: ${{ inputs.folder-path }}

    - name: check diff between old output and binary after cleaned
      run: diff <(./$(grep NAME < config.mk | grep -v NAME_DEBUG | cut -d'=' -f2 | xargs)) /tmp/release_output
      shell: bash
      working-directory: ${{ inputs.folder-path }}

    - name: make fclean
      run: make fclean
      shell: bash
      working-directory: ${{ inputs.folder-path }}

    - name: check diff between old project architecture and the actual project architecture
      run: diff <(ls -lRS) /tmp/tree_hierarchy
      shell: bash
      working-directory: ${{ inputs.folder-path }}

    - name: make re
      run: make re
      shell: bash
      working-directory: ${{ inputs.folder-path }}

    - name: make debug
      run: make debug
      shell: bash
      working-directory: ${{ inputs.folder-path }}

    - name: make redebug
      run: make redebug
      shell: bash
      working-directory: ${{ inputs.folder-path }}
